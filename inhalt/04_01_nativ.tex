Als erste Implemetierung soll nun die native Android Applikation vorgestellt werden. Wie bereits in der Abgrenzung erwähnt, beschränkt sich diese Arbeit auf eine Android Implementierung, um einerseits den Aufwand zu begrenzen und da es wie bereits aufgezeigt native Implementierungen grundsätzlich vergleichen lassen, da diese direkt auf die meist auf beiden Plattformen vorhandenen spezifischen Schnittstellen zugreifen. Außerdem sind die grundsätzlichen Entwicklungskonzepte die gleichen und lediglich die Feinheiten der Programmiersprache unterscheiden sie.

\subsection{Grundlagen}
Solange es Smartphones gibt, gibt es auch schon die native Entwicklung. Android etwa wurde 2008 vorgestellt. Damals wurden die Apps in Java entwickelt, eine Sprache die in der Anwendungsentwicklung damals und heute noch sehr gut bekannt ist und auch oft noch als Programmiersprachen an den Universitäten gelehrt wird. 2019 jedoch änderte Google die offiziell bevorzugte Programmiersprache zu Kotlin. Kotlin wurde von Jetbrains entwickelt um einen Ersatz für Java zu finden, dass alle benötigten Funktionen für eine effektive Appentwicklung hat, jedoch genauso schnell kompiliert werden kann. Mittlerweile ist es nichtmehr nur noch die bevorzugte Sprache von Google, sondern auch von den Entwicklern. //Kotlin Apple ihre ersten Applikationen für iOS mit Objectiv-C programmiert. Beide Arten werden auch weiterhin unterstützt. Jedoch gibt es mittlerweile Programmiersprachen, die speziell an die Bedürfnisse der Betriebssysteme angepasst sind und deren Entwicklung die Firmen selbst vollständig in der Hand haben, um schnell und Unkompliziert benötigte Änderungen vornehmen zu können. So empfiehlt Apple mittlerweile Swift und Android die Verwendung von Kotlin.

 So ist Kotlin eine auf Java basierende Programmiersprache die bidirektional übersetzt werden kann. So kann man alten Java Code in die Kotlin App einbinden und automatisch übersetzen lassen. Außerdem wird der Kotlin Code zum bauen der App in Java übersetzt und dann in Java ausgeführt.
Nachdem dies aus dem Weg geschafft ist und wir uns also für Kotlin in diesem Fall entschieden haben, gibt es nun weitere Entscheidungen zu treffen. Bei Android Apps kann man grundsätzlich zwischen zwei verschiedenen Arten des Seitenaufbaus und der Grundarchitektur. 
Diese nennen sich Activitys bzw. Fragments. Sie sind die Entscheidung für eine Art Grundstruktur. Bei Activitys sind die einzelnen Seiten unterschiedliche Klassen und eigenständige Systeme. Jede Activity hat ihren eigenen Context und wird selbständig auf dem Bisldschirm aufgebaut. Danach wird neben ein paar ausnahmen nur zwischen den eigenen Activitys hin und her navigiert um den Ablauf der App nachzubilden.
Bei Fragments haben diese einen geteilten Kontext. Sie werden alle gleichzeitig gebaut und werden dann nur darübergelegt bzw. vom Bildschirm entfernt. Ein großer Vorteil dieser Methode ist, dass man wenn man genügend Platz hat, zwei Bildschirme nebeneinander angezeigt werden können und diese beide normal funktionieren. Bei kleinen Bildschirmen oder unter Umständen kann auch dann nur ein Fragment angezeigt werden. Somit zeigt sich, dass vorallem für Anwendungen die sowohl auf Tablet und Handy Problemlos genutzt werden sollen, Fragments sich gut eignen.
Beide Ansätze haben ihre Vor- und Nachteile.
Für diese Arbeit wurde entschieden auf die Activitys Architektur zurück zu greifen, da sie anfänglich einfacher ist und Schwierigkeiten mit dem Kontextmanagment und dem App Backstack zum navigieren durch die History reibungsloser funktioniert. Außerdem sind Activities aktuell besser dokumentiert und viele Problemlösungen sind für Activities beschrieben.

Nach dem man sich nun für eine Grundarchitektur entschieden hat, müssen ein paar Entscheidungen anhand der Projektarchitektur getroffen werden. Ersteinmal muss man entscheiden ob man eine lokale Offline Datenbank braucht oder ob man eine Onlinedatenhaltung mit eventuell angebundener Serverlogik hat. Natürlich kann auch beides gemacht werden. Jedoch in diesem Fall werden wir nur eine Onlinedatenhaltung benutzen die über eine API angebunden ist. 


Ärgerlich bei der Nativ Entwicklung und Graphql war, dass neu erzeugte Querys erst durch ein Build durchlauf erzeugt wurden, und so etwas längert braucht zur Entwicklung.

\subsection{Schwierigkeiten}
\subsection{genutzte externe Bibliotheken}
\subsection{Fazit Nativ}