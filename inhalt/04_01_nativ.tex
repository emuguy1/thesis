Solange es Smartphones gibt, gibt es auch schon die native Entwicklung. Android etwa wurde 2008 vorgestellt. Damals wurden die Apps für Android in Java entwickelt, eine Sprache die in der Anwendungsentwicklung damals und heute noch sehr gut bekannt ist und auch oft noch als Programmiersprachen an den Universitäten gelehrt wird. 2019 jedoch änderte Google die offiziell bevorzugte Programmiersprache zu Kotlin. Kotlin ist von Jetbrains entwickelt um einen Ersatz für Java zu finden. Sie entwickelten eine Sprache die alle benötigten Funktionen für eine effektive Appentwicklung hat, jedoch genauso schnell kompiliert werden kann. Eine ähnliche Entwicklung fand auch bei Apple statt, die in Folge dessen von Objectiv-C zu Swift wechselten. Durch die Entwicklung eigener Sprachen haben sie die Kontrolle was in den Sprachen passiert und können diese perfekt für ihre Bedürfnisse anpassen.\TODO{Quelle}

Nachdem dies auch die ürsprünglichste Variante der Entwicklung war, soll nun als erste Implementierung die native Android Applikation betrachtet werden.

\subsection{Grundlagen}
\subsubsection{Layoutgrundlagen}
Die native Android App wurde mit Kotlin geschrieben. Um eine Kotlin App zu programmieren, erzeugt man ein Design für die Seite und eventuelle Elemente mit Hilfe der XML-Notation geschrieben.
In dieser XML Datei baut man ähnlich zu einer HTML Seite die Oberfläche auf. So startet man mit einem Basiselement, dass eine Art von Layoutelement ist. So kann man etwa neben einem linearem Layout oder einem Tabellenlayout auch das so genannte Constraint-Layout wählen. Das Constraint-Layout ist mit unter das wichtigste Layout in Android und funktioniert, wie der Name bereits andeutet, in dem man die Positionen der Elemente abhängig von anderen Elementen definiert. So kann man Elemente über das setzen der Abhängigkeit der oberen Kante und der linken Karte mit den jeweiligen Kanten des Layouts in die linke obere Ecke bringen. Durch das hinzufügen einer Abhängigkeiten von beiden Kanten in einer Richtung, wird das Element dann etwa innerhalb der Abhängigkeit zentriert. Über den sogenannten Bias kann dann je nach Wert ausgehend von 0,5 in die jeweiligen Richtungen verschoben werden. Bei einem beidseitigen Constraint in horizontaler Richtung würde der Wert 0 etwa heißen, dass der Start des Elements linksbündig zur Startabhängigkeit wäre, während bei 1 das Ende des Elements rechtsbündig wäre. Eine weitere Besonderheit ist, dass in diese Fall auch die Breite des Elements auf 0 gesetzt werden könnte, damit dass Element die komplette Breite einnimmt, die laut der Abhängigkeiten des Elements zur Verfügung stehen. Wegen dieser Fähigkeiten ist dieses Layout von Google das empfohlene Layout, da man gut auf unterschiedliche Bildschirmgrößen durch das Setzen sinnvoller Abhängigkeiten reagieren kann \cite{Google_Constraint_Layout}.

Ein weiteres wichtiges Element um in Android das Layout zu designen sind die Attribute Margin und Padding. Sie könne zu jedem Element hinzugefügt werden, und bestimmen den äußeren beziehungsweise inneren Abstand zum Inhalt des Elementes. Durch das sinvolle Setzen von äußeren Abständen kann etwa ein überlappen der einzelnen Elemente verhindert werden.

\subsubsection{Aufbau}
In Android gibt es eine Hauptklasse, die sogennante Activity. In ihr wird alles gesteuert. Das Layout wird aufgerufen und der aktuellen Seite hinzugefügt, es werden alle Funktionalitäten zu den Elementen der Benutzeroberfläche hinzugefügt und ordnet der Oberfläche die Daten und den Listen ihre seperaten Controller zu.

Als zweite Klasse kommen ListAdapter dazu. In Android werden Listen mit sogenannten RecyclerViews gebaut. Das sind Listen, deren Elemente wiederverwendet werden, sobald sie ausserhalb des Sichtfeldes sind. Um dies unterstützen zu können oder auch unterschiedliche Elemente einer Liste hinzuzufügen, muss diese natürlich gesteuert werden. Die Adapter werden von der Activity erzeugt und der Listenansicht der Oberfläche hinzugefügt. Dazu bekommt es eine Liste an Elementen hinzugefügt.
Innerhalb des Adapters wird dann das Layout eines Elements definiert und sobald das Element der Oberfläche hinzugefügt werden soll, wird ihm ähnlich zu der Activity die einzelnen Informationen aus dem Datenelement und Funktionalität hinzugefügt.

Die dritte Klasse sind ViewModels. Diese sind die Schnittstelle zwischen der Datenhaltung und der Activity. Sie kümmern sich um die Beschaffung und das Managen der Daten für die Activity. Das Besondere an ViewModels ist, dass diese erst beendet werden, wenn ihre zugeordente Elternklasse final beendet wird. So werden ViewModels bei einer Konfigurationsänderung, wenn etwa das Gerät gedreht wird, nicht beendet. Dadurch wird lediglich die Oberfläche neu gebaut, die Daten müssen aber nicht neu beschafft werden, was die Performance verbessert. Dazu laufen ViewModels auf einem anderen Thread als den MainThread. Dadurch können Daten im Hintergrund abgefragt werden, ohne den MainThread und damit die Nutzeroberfläche zu blockieren.


\subsection{genutzte Bibliotheken}
Als erste Bibliothek wird Apollo Kotlin  für die GraphQl-Kommunikation gewählt. "Apollo Kotlin ist ein GraphQL Client, der Kotlin und Java Modelle von GraphQL Queries erzeugt."\cite{Apollo_kotlin_docs} Apollo bietet neben einem Android Client auch Clients für iOS und React Native. Die anfängliche Konfiguration ist dabei denkbar einfach. Man erzeugt eine Konfigurationsdatei, in denen die Endpunkte definiert werden und definiert eine Datei in der das Schema der GraphQLSchnittstelle automatisch bei einer Verbindung geladen wird. Im Anschluss kann man einzelne GraphQL-Datein erstellen, in denen man die verschiedenen Querys oder Mutationen definiert. Diese kann man außerdem direkt in Android Studio testen und die Ergebnisse betrachten. Es ermöglicht einem also direkt Fehler in der Implementierung zu erkennen und zu beheben. 
Aus den verschiedenen Implementierten GraphQL Befehlen werden im Anschluss während des bauen der Applikation dann Befehl-Modelle erstellt, Diese können dann aufgerufen werden und liefern bei erfolgreicher Verbindung mit dem Server ein Antwortobjekt zurück. Auch der Zugriff auf die Ergebnisse funktioniert dabei denkbar einfach. Dadurch dass die Library sich die genaue Schnitstellendefinition von dem Server holt, dadurch die Datentypen der einzelnen Elemente kennt und dadurch die Results automatisch von dem JSON Format in ein Objekt übersetzen. Dadurch kann auch nicht durch Schreibfehler der Zugriff schief laufen. Um den Client global zu speichern und überall benutzen zu können wurde die Configuration global in der Applikation gespeichert. Da es ja einen Login in der App gibt, wird mit erfolgreichem Login der Client neugebaut und dabei der URL als Parameter die Authentifizierung hinzugefügt. Dementsprechend wird beim Login die URL wieder zurückgeändert.

Eine andere Bibliothek die genutzt wird ist Room. Sie ist teil von Android Jetpack, dass ein Set an Bibliotheken ist, dass helfen soll, einfach und sauber Apps zu bauen, die über die verschiedenen Android-Versionen hinweg funktionieren \cite{Jetpack_android}. Room selber ist dabei der Teil, der es ermöglichen soll einen ordentlichen Datenbank Zugriff zu haben. Die Besonderheit ist, dass durch Room eine Zwischenebene geschaffen wird, die nicht nur die geschriebenen SQL Befehle überprüft und validiert, umfangreiche asynchronität der Datenbankoperationen ermöglicht, sonder auch hilfreiche Annotation anbietet, um redundanten Code zu verhindern \cite{Room_docs}.

Zum Speichern des Authentifizierungsstrings wurden als letzte relevante Bibliothek sogenannte Shared-Preferences genutzt. Sie sind ein weiterer Teil von Android Jetpack. Ein SharedPreferences Object verweist dabei auf eine Datei innerhalb des Applikationsordners, in der Key-Value Werte gespeichert werden können. Man kann dabei Werte im Format von primitiven Datentypen hinzufügen, ändern, abfragen oder auch löschen. Dabei findet der Zugriff immer über den Key vom Typ String statt. Durch diese Funktionalität kann man ohne großen Aufwand Daten dauerhaft speichern und überall innerhalb der Applikation abfragen, ohne dafür eine eigene Entität in der Datenbank anzulegen. Dies ist besonders gut für Werte wie Authentifizierung oder bestimmte Flags geeignet um den Status der App zu bestimmen.

Neben diesen Bibliotheken wurden ein paar weiter genutzt, die jedoch lediglich für bestimmte Designelemente notwendig waren und somit keine Rolle in dieser Arbeit spielen.

\subsection{Schwierigkeiten}
Die Entwicklung der nativen App lief eigentlich sehr geordnet und einfach ab. Schwierigkeiten waren lediglich, dass die Graphql Befehle erst nach einem erneuten Bauen der App generiert wurden, wodurch der Entwicklungsprozess aufgehalten wurde. Dazu kommt, dass man sich um Änderungen an Listen oder Logik zu betrachten immer die App starten muss und dabei oft auf den Anfang der Applikation zurpckgesetzt wurde, wenn es sich nicht nur um einfache Designänderungen gehandelt hat. Dies verlangsamte den Entwicklungsprozess.

\subsection{Fazit Android Nativ}
Nativ hat einige Vorteile. Es ist ein gut dokumentierter am längsten existierender Ansatz, für den es für fast alle Probleme eine erprobte und funktionierende Lösung gibt. So war das Finden einer passenden GraphQL Bibliothek eine Leichtigkeit, da Apollo in diesem Bereich für Kotlin als Standarbibliothek gibt. Dazu kommt, dass es viele Bibliotheken gibt, die Google/JetBrains selber anbieten, um die Entwicklung von Apps zu vereinfachen und zu standardisieren.  
Ein vorteil der nativen Layoutentwicklung ist, dass man das Layout in einer sofortigen Anzeige zusammenbauen kann und somit immer sofort sehen kann wie es aussieht. Außerdem bietet Android Studio eine Funktion an, dass man die Bildschirmgröße dynamisch ändern kann, um die Kompatibilität mit anderen Bildschirmgrößen zu testen. Jedoch hat dies seine Beschränkung, da alle dynamisch hinzugefügten Sachen, erst in der tatsächlich laufenden Applikation sehen kann.
\TODO{Eventuell das ganze komplett verschieben.}


 --Eventuell : Hier kann man einmal mehr auch die Ähnlichkeiten der Android und iOS Entwicklung sehen. Denn auch iOS biet eine UI um den geschreibenen Code zu sehen. Auch hier werden die Elemente in ein Layout gesteckt und auch hier wird um auf unterschiedliche Bildschirmgröße zu reagieren auf ein Abhängigkeiten basiertes Layout gesetzt.