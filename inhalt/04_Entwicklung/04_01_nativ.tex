\section{Entwicklung Nativer Android Applikation}
Die native Entwicklung ist die ursprünglichste von allen Arten. Android etwa wurde 2008 vorgestellt. 
Damals wurden die Apps für Android noch in Java entwickelt, eine Sprache die in der Anwendungsentwicklung damals und heute noch sehr gut bekannt ist und auch oft noch als Programmiersprachen an den Universitäten gelehrt wird. 
Jedoch änderte Google die offiziell bevorzugte Programmiersprache 2019 zu Kotlin\footnote{https://developer.android.com/kotlin}. 
Kotlin wurde von Jetbrains entwickelt, um einen Ersatz für Java zu finden. 
Sie entwickelten eine Sprache die alle benötigten Funktionen für eine effektive Appentwicklung hat, jedoch genauso schnell kompiliert werden kann. 
Eine ähnliche Entwicklung fand auch bei Apple statt, bei der von Objectiv-C zu Swift gewechselt wurde. 
Durch die Entwicklung eigener Programmiersprachen, haben die Plattformentwickler die Kontrolle, welche Funktionalitäten hinzugefügt oder entfernt werden und können diese perfekt für ihre Bedürfnisse anpassen \cite{medium_Swift_Kotlin}.

\subsection{Grundlagen}
Die Entwicklung einer nativen Android App besteht aus zwei separaten Teilen, 

Der erste Teil ist das Layout. Dabei wird das Design für die UI und eventuelle Elemente mit Hilfe der XML-Notation erstellt.
In der XML Datei wird ähnlich zu einer HTML Datei, die Oberfläche aufgebaut. Als Wurzelelement hat eine Seite dabei ein Layoutelement. Neben einem linearem Layout oder einem Tabellenlayout, gibt es hier vor allem das so genannte Constraint-Layout\footnote{https://developer.android.com/guide/topics/large-screens/support-different-screen-sizes}. 
Es ist ein wichtiges Layout in Android, da, wie der Name bereits andeutet, die Positionen der Elemente abhängig von anderen Elementen definiert ist. Durch diese Eigenschaft, eignet es sich, um Designs für unterschiedliche Bildschirmgrößen zu erstellen \cite{ConstraintLayout_Android}. Es bietet dabei nicht nur die Möglichkeit, die Position, sondern auch die Größe abhängig von anderen Elementen zu definieren.
Die eigentliche Benutzeroberfläche wird durch Verschachtelung und Anordnung von UI-Elementen innerhalb des Grundlayouts gebaut. Diese können dabei sowohl von Android vordefiniert oder von externen Bibliotheken stammen. Die erstellten Dateien beinhaltet lediglich das Layout und keinerlei Funktionalität.

Der zweite Teil der Implementierung ist der Logik und Funktionalitätsteil der Anwendung. Dieser kann wiederum in drei Klassen unterteilt werden. 
Die erste Klasse, die sogenannte Activity\footnote{https://developer.android.com/reference/kotlin/android/app/Activity} ist die Hauptklasse für eine Seite. In ihr wird das Layout aufgerufen und der aktuellen Seite hinzugefügt, den Elemente der UI ihre Funktionalität zugeordnet, in der Oberfläche die benötigten Daten ergänzt und vorhandenen Listen ein Controller hinzugefügt \cite{sarkar_android}.
Diese Controller, genannt ListAdapter\footnote{https://developer.android.com/reference/androidx/recyclerview/widget/ListAdapter} sind die zweite Klasse. Sie werden bei dynamischen Listen in Android benötigt, da diese so designt sind, dass Listenobjekte die außerhalb der sichtbaren Bereiches sind, wiederverwendet werden \cite{recyclerview_android}. Dafür benötigt jede Liste einen eigenen Adapter, der das benötigte Design, Daten und Funktionalität dem Listenelement hinzufügt.
Die dritte Klasse sind ViewModels\footnote{https://developer.android.com/topic/libraries/architecture/viewmodel}. Diese sind die Schnittstelle zwischen der Datenhaltung und der Activity und verringern damit die Koppelung von Benutzeroberfläche und der Datenhaltung \cite{viewModel_android}. Neben dem asynchronen Sammeln von Daten aus ihren Quellen, kann ein ViewModel außerdem Daten speichern, die eine Konfigurationsänderung überstehen sollen. Knofigurationsänderungen sind dabei Änderungen, die einen Neustart der Activity nych sich ziehen\footnote{https://developer.android.com/guide/topics/resources/runtime-changes}. Dazu zählt etwa das Ändern der Bildschirmausrichtung. ViewModels überstehen eine solche Änderung und können nach dem erneuten Bauen der Aktivität dieser wieder hinzugefügt werden. Sie werden erst beendet, wenn die dazugehörige Activity geschlossen wird. Dadurch können sowohl Daten zwischengespeichert werden, als auch verhindert werden, dass Daten unnötig oft abgefragt werden.


\subsection{Genutzte Bibliotheken}
Zur Kommunikation mit der GraphQL-Schnittstelle der genutzten Webanwendung, wird Apollo Kotlin\footnote{https://www.apollographql.com/docs/kotlin/} genutzt. 
Es ist ein GraphQL Client, der geschriebenen GraphQL Queries in Kotlin und Java Modelle umwandelt, die daraufhin wie normale Objekte in der Implementierung aufgerufen werden können.
Anfänglich stellt die Bibliothek während der Entwicklung eine Verbindung mit der GraphQL-API her, um die Schnittstellendefinition abzufragen und zu speichern. Dadurch kann der Client die Antworten der Schnittstelle, die in einem JSON Format geliefert werden, automatisch den jeweiligen Datentypen zuordnen. Daher ist der Zugriff auf die Antwort des Servers besonders sicher möglich, da Schreibfehler in der Abfrage der Daten verhindert werden können.
Damit der Client in der kompletten Applikation genutzt und wenn nötig abgeändert werden kann, wird er der Applikation als globales Attribut hinzugefügt.

Die zweite wichtige Bibliothek die genutzt wird, ist Room\footnote{https://developer.android.com/training/data-storage/room}. Sie ist Teil von Android Jetpack\footnote{https://developer.android.com/jetpack}, einm Set an Bibliotheken, dass Entwickler helfen soll, Apps für verschiedene Android-Versionen problemlos zu bauen. Room selber ist dabei der Teil, der es ermöglichen soll einen möglichst effizienten Datenbank Zugriff zu haben.
Die Besonderheit ist, dass Room eine Zwischenebene darstellt, die die geschriebenen SQL Befehle überprüft und validiert. Des Weiteren wird durch die Nutzung von Annotationen redundanter Code verhindert und eine Asynchronität der Datenbankoperationen vereinfacht \cite{Room_docs}.

Zum Speichern des Authentifizierungsstrings wurden sogenannte Shared-Preferences\footnote{https://developer.android.com/reference/android/content/SharedPreferences} genutzt. Sie sind ein weiterer Teil von Android Jetpack. Sie werden genutzt, um Key-Value Werte ohne großen Aufwand innerhalb der Applikation zu speichern. Sie können von innerhalb der ganzen Applikation abgefragt hinzugefügt, geändert oder gelöscht werden. Hierfür muss keine eigene Entität in der Datenbank angelegt werden und der Zugriff ist schneller. Sie sind jedoch nur für einfache Daten geeignet, da lediglich primitive Datentypen genutzt werden können. Daher werden sie vor allem für Werte wie Authentifizierung oder bestimmte Flags geeignet um den Status der App zu bestimmen.


\subsection{Fazit Android Nativ}
Der native Ansatz ist sehr gut dokumentiert. Für fast jedes Probleme, wie etwa der GraphQl Kommunikation, kann eine erprobte und gut funktionierende Lösung gefunden werden. Dazu kommt, dass es viele Bibliotheken gibt, die Google beziehungsweise JetBrains selber anbieten, um die Entwicklung von Apps zu vereinfachen und zu standardisieren.

Ein Vorteil der Layoutentwicklung in diesem Bereich ist, dass das Layout in einer sofortigen Anzeige zusammengebaut werden kann und somit das Aussehen sofort ersichtlich ist. Dies ist dabei sowohl bei der nativen Android als auch der nativen iOS Entwicklung möglich. Jedoch ist diese Anzeige nur auf die Oberfläche ohne Funktionalität oder von der Activity hinzugefügte Daten beschränkt. Wenn also Änderungen betrachtet oder getestet werden sollen, so muss die App dennoch neu gebaut werden. Neben der Zeit, die es dauert die Änderungen zu laden, startet die App dabei wieder vom Startbildschirm neu, weshalb wieder zu der entwickelten stelle navigiert werden muss, um Änderungen zu testen. Dadurch wird der Entwicklungsprozess verlangsamt und erschwert,
