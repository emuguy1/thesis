\section{Entwicklung Nativer Android Applikation}
Die native Entwicklung ist die ursprünglichste von allen Arten. Android etwa wurde 2008 vorgestellt. 
Damals wurden die Apps für Android noch in Java entwickelt, eine Sprache die in der Anwendungsentwicklung damals und heute noch sehr gut bekannt ist und auch oft noch als Programmiersprachen an den Universitäten gelehrt wird. 
Jedoch änderte Google die offiziell bevorzugte Programmiersprache 2019 zu Kotlin\footnote{https://developer.android.com/kotlin}. 
Kotlin wurde von Jetbrains entwickelt, um einen Ersatz für Java zu finden. 
Sie entwickelten eine Sprache die alle benötigten Funktionen für eine effektive Appentwicklung hat, jedoch genauso schnell kompiliert werden kann. 
Eine ähnliche Entwicklung fand auch bei Apple statt, bei der von Objectiv-C zu Swift gewechselt wurde. 
Durch die Entwicklung eigener Programmiersprachen, haben die Plattformentwickler die Kontrolle, welche Funktionalitäten hinzugefügt oder entfernt werden und können diese perfekt für ihre Bedürfnisse anpassen \cite{medium_Swift_Kotlin}.

\subsection{Grundlagen}
Die Entwicklung einer nativen Android \acp{App} besteht aus zwei separaten Teilen, 

Der erste Teil ist das Layout. Dabei wird das Design für die UI und eventuelle Elemente mit Hilfe der XML-Notation erstellt.
In der XML Datei wird ähnlich zu einer HTML Datei, die Oberfläche aufgebaut. Als Wurzelelement hat eine Seite dabei ein Layoutelement. Neben einem linearem Layout oder einem Tabellenlayout, gibt es hier vor allem das so genannte Constraint-Layout\footnote{https://developer.android.com/guide/topics/large-screens/support-different-screen-sizes}. 
Es ist das wichtigste Layout in Android, da wie der Name bereits andeutet, die Positionen der Elemente abhängig von anderen Elementen definiert ist. Durch diese Eigenschaft, eignet es sich, um Designs für unterschiedliche Bildschirmgrößen zu erstellen. Es bietet dabei nicht nur die Möglichkeit, die Position, sondern auch die Größe abhängig von anderen Elementen zu definieren. In dem gewählten Layoutelement wird danach die restliche Oberfläche durch andere Elemente abgebildet. Dabei kann sowohl vordefinierte Elemente von Android genutzt werden, als auch in anderen Dateien definierte Elemente. Die erstellte Datei beinhaltet dabei lediglich das Layout und keinerlei Funktionalität.

Der zweite Teil der Implementierung ist die Logik. Sie kann in drei Klassen unterteilt werden. 
Die erste Klasse, die sogenannte Activity ist die Hauptklasse für eine Seite. In ihr wird alles gesteuert. Das Layout wird aufgerufen und der aktuellen Seite hinzugefügt, es werden alle Funktionalitäten zu den Elementen der Benutzeroberfläche hinzugefügt und ordnet der Oberfläche die Daten und den Listen ihre separaten Controller zu.

Dies ist ebenfalls die zweite Klasse. ListAdapter sind die Controller Klassen für Listen in Android. Listen werden dabei mit Elementen gebaut , die wiederverwendet werden, sobald sie außerhalb des Sichtfeldes sind. Dafür benötigt jede Liste einen Adapter, der dafür verantwortlich ist, die richtigen Elemente auszuwählen und Funktionalität und Daten hinzuzufügen.

Die dritte Klasse sind ViewModels\footnote{https://developer.android.com/topic/libraries/architecture/viewmodel}. Diese sind die Schnittstelle zwischen der Datenhaltung und der Activity. In einem ViewModel werden Daten abgefragt und Daten zwischengespeichert, die eine Konfigurationsänderung überstehen sollen. Diese sind etwa eine Änderung der Orientierung des Gerätes. Dies ist möglich, da ViewModels erst beendet werden, wenn ihre zugeordnete Aktivität final beendet wird. 
Durch die Nutzung kann die Performance verbessert werden. Es werden unnötige mehrfach Abfragen von Daten verhindert. Dazu kommt, dass ViewModels auf einem anderen Thread laufen als die Activity. Dadurch kann diese Events der \ac{UI} abfangen und weiterhin reagieren, während das ViewModel die nötige Daten sammelt.


\subsection{Genutzte Bibliotheken}
Die Bibliothek, die zur GraphQl-Kommunikation gewählt wurde, ist Apollo Kotlin\footnote{https://www.apollographql.com/docs/kotlin/}. 
Es ist ein GraphQL Client, der geschriebenen GraphQL Queries in Kotlin und Java Modelle umwandelt, die daraufhin wie normale Objekte in der Implementierung aufgerufen werden können. 
Anfänglich wird eine Konfigurationsdatei erstellt, in der Sachen wie der GraphQL-Endpunkt definiert werden. 
Danach stellt der Client eine Verbindung zu der GraphQL-\ac{API} her und fragt die Schnittstellendefinition ab, die im Anschluss gespeichert werden. 
Danach können die einzelnen GraphQL Befehle in einzelne Datein geschrieben werden, die wie bereits erwähnt automatisch in aufrufbare Objekte verwandelt werden.

Da Apollo die genaue Schnittstellendefinition kennt, erzeugt es automatisch aus der \ac{JSON}-Antwort des Servers ein Objekt und ordnet den einzelnen Stufen der Antwort die jeweiligen Datentypen zu.
Damit der Client in der kompletten Applikation genutzt und wenn nötig abgeändert werden kann, wird er der Applikation als globales Attribut hinzugefügt.

Die zweite wichtige Bibliothek die genutzt wird, ist Room\footnote{https://developer.android.com/training/data-storage/room}. Sie ist Teil von Android Jetpack\footnote{https://developer.android.com/jetpack}, dass ein Set an Bibliotheken ist, dass helfen soll, einfach und sauber Apps zu bauen, die über die verschiedenen Android-Versionen hinweg funktionieren \cite{Jetpack_android}. Room selber ist dabei der Teil, der es ermöglichen soll einen möglichst effizienten Datenbank Zugriff zu haben. 
Die Besonderheit ist, dass Room eine Zwischenebene darstellt, die sowohl die geschriebenen SQL Befehle überprüft und validiert, die asynchronität der Datenbankoperationen vereinfacht und durch Annotation redundanten Code verhindert \cite{Room_docs}.

Zum Speichern des Authentifizierungsstrings wurden sogenannte Shared-Preferences\footnote{https://developer.android.com/reference/android/content/SharedPreferences} genutzt. Sie sind ein weiterer Teil von Android Jetpack. Sie werden genutzt, um Key-Value Werte ohne großen Aufwand innerhalb der Applikation zu speichern. Sie können von innerhalb der ganzen Applikation abgefragt hinzugefügt, geändert oder gelöscht werden. Hierfür muss keine eigene Entität in der Datenbank angelegt werden und der Zugriff ist schneller. Sie sind jedoch nur für einfache Daten geeignet, da lediglich primitive Datentypen genutzt werden können. Daher werden sie vor allem für Werte wie Authentifizierung oder bestimmte Flags geeignet um den Status der App zu bestimmen.


\subsection{Fazit Android Nativ}
Nativ hat einige Vorteile. Es ist ein gut dokumentierter Ansatz, für den es für fast alle Probleme eine erprobte und funktionierende Lösung gibt. So war das Finden einer passenden GraphQL Bibliothek eine Leichtigkeit, da Apollo in diesem Bereich für Kotlin als Standardbibliothek gilt. Dazu kommt, dass es viele Bibliotheken gibt, die Google/JetBrains selber anbieten, um die Entwicklung von Apps zu vereinfachen und zu standardisieren.

Ein Vorteil der Layoutentwicklung in diesem Bereich ist, dass das Layout in einer sofortigen Anzeige zusammengebaut werden kann und somit das Aussehen sofort ersichtlich ist. Dies ist dabei sowohl bei der nativen Android als auch der nativen iOS Entwicklung möglich. Jedoch ist diese Anzeige nur auf die Oberfläche ohne Funktionalität oder von der \verb|Activity| hinzugefügte Daten beschränkt. Wenn also Änderungen betrachtet oder getestet werden sollen, so muss die App dennoch neu gebaut werden. Neben der Zeit, die es dauert die Änderungen zu laden, startet die App dabei wieder vom Startbildschirm. Dadurch wird der Entwicklungsprozess verlangsamt und erschwert,
