\section{Entwicklung einer hybriden, cross-kompilierten Applikation mit WebView und Flutter}
Die vierte Implementierung gehört zu den gemischten Ansätzen. Sie besteht aus dem Mix einer hybriden Applikation und einer cross-kompilierten Applikation. Hierbei wird zwischen reinen Flutter-Benutzeroberflächen und einer in Flutter implementierten WebView hin und hergeschaltet, um eine Multi-Plattform Applikation zu erstellen. Durch diese Mischung soll einerseits die bereits bstehende Webseite genutzt werden um eine Neuimplementierung zu vermeiden, jedoch sollen bestimmte Teile des Systems für die mobile Nutzung angepasst werden und durch eigens programmierter Funktionalität ersetzt werden. Dabei soll jedoch weiterhin die Möglichkeit bestehen, die individuellen Applikationen aus einer Code-Basis zu kompilieren.

\subsection{Grundlagen}
Es gelten für diese Implementierung die gleichen Grundlagen wie in der vorherigen Flutter Implementierung. Jedoch wird eine WebView hinzugefügt und zwischen Web-Oberflächen und Flutter-Seiten hin und her gewechselt.
Da dies kein verbreiteter Ansatz ist und es keine offizielle Dokumentation oder Anleitungen für diesen Ansatz gibt, mussten hierzu einige Herausforderungen überwunden werden, die im folgenden etwas erklärt werden sollen.

Die Integration der Webseite ist zunächst wieder ähnlich zu dem Vorgehen in der hybriden Applikation. So werden die aufgerufenen URLs abgefangen und eine von drei Entscheidungen getroffen. So werden Links zu externen Webseiten im Browser des Gerätes geöffnet. URL´s der eigenen Web-Anwendung, bei der die Web-Ansicht genutzt werden sollen, werden geladen und URL's die zu Seiten gehören, die durch eine Flutter Seite angezeigt werden sollen, werden abgelehnt und die entsprechende Flutter Seite wird mit eventuellen Parametern aus der URL geladen. Bei der Implementierung der Filterung muss dementsprechend die Unterscheidung und Analyse der URL viel genauer und feingradiger stattfinden.

Flutter beendet standardmäßig alle nicht mehr angezeigten Seiten und löscht dabei auch mögliche gespeicherte Informationen wie etwa die Navigationshistorie des WebViews. Da diese jedoch benötigt wird, um ein Navigieren innerhalb der Webanwendung umkehrbar zu machen, wird eine Möglichkeit benötigt um die Werte der WebView zu speichern. Dafür wurde das von Flutter bereitgestellte \verb|AutomaticKeepAliveMixin|\footnote{https://api.flutter.dev/flutter/widgets/AutomaticKeepAliveClientMixin-mixin.html} verwendet. 
Wie der Name schon ganz gut beschreibt, markiert er damit den State eines Widgets, sodass die Garbage Collection diesen nicht  löscht. Bei einem erneuten Aufruf der Seite wird daher einfach der noch vorhandede State geladen und weiter genutzt, sodass ein zurücknavigieren in der Webseite auch nach dem Besuch einer Flutter Seite weiterhin möglich ist.

Eine weitere Herausforderung bei dieser Implementierung ist die Navigation.
Dabei ist das navigieren zu einer neuen Seite ohne Probleme durch die Navigation der WebView möglich. Die aufgerufene URL werden abgefangen und ,wie bereits erklärt, weiterverarbeitet. Aus einer Flutter-Ansicht heraus wird entweder zu einer anderen Flutter-Ansicht navigiert oder die neue URL in der WebView aufgerufen. Bei der Rückwärtsnavigation ist dies jedoch ein Problem. So kann die Flutter Navigation ohne Probleme von einer FlutterSeite in die WebView zurückkehren und dort die Navigation der WebView übernehmen, jedoch wird dies ein Problem wenn im Verlauf der Historie zu einer Flutter-Seite gewechselt und dann wieder in die WebView weiternavigiert wurde. Dabei liegt die Schwierigkeit bei der Methode, die die URL's filtert und verarbeitet. Diese wird lediglich bei einem Neuaufruf einer URL ausgelöst, jedoch nicht, wenn zurück navigiert wird. So wurde in diesem Fall die Web-Version anstatt der für mobil optimierte Flutter Seite angezeigt. Daher ist diese Art der Navigation nicht möglich.
Um diese Herausforderung zu überwinden, wurden zwei Mögliche Lösungen erarbeitet:
\begin{enumerate}
    \item Eine eigene Navigation schreiben, in der genau definiert wird, wann genau in der WebView etwas aufgerufen wird und wann eine Flutter Seite aufgerufen wird. 
    \item Jedes mal, wenn von einer Flutter Seite zurück in eine WebView gewechselt wird, eine neue WebView erzeugen und somit die ganz normalen Navigationen von Flutter und der WebView nutzen. 
\end{enumerate}

Beide Lösungen haben ihre Vor und Nachteile. So ist der erste Ansatz zwar Ressourcen sparender, da lediglich eine WebView genutzt wird, jedoch wird hier ein hoher Implementierungsaufwand benötigt um eine eigene Navigation zu schreiben. 
Beim zweiten Ansatz ist die Performance zwar etwas schlechter, jedoch kann die von Flutter bereitgestellte Navigation genutzt werden und somit Fehler bei einer Implementierung und hoher Programmieraufwand verhindert werden.
Wenn zusätzlich sinnvolle Punkte in der App definiert werden, an der die Navigationshistorie der Flutternavigation gelöscht wird, können dadurch alte WebView Konfigurationen von der Garbage Collection gelöscht werden und der Effekt auf die Performance eingeschränkt werden. Daher wurde bei der Implementierung die zweite Lösung gewählt. 

Eine letzte Herausforderung war der Mix der verschiedenen Technologien. So wurde bei der Web-Implementierung eine sogenannte Live-Komponente benutzt, die dafür sorgt, dass bei einem Wechsel von einer Seite zu einer anderen, keine neue URL geladen wird, sondern lediglich der Inhalt dynamisch nachgeladen und der neue angezeigt wird. Dies war etwa der Fall bei der Implementierung des Chats. So war die Überssichtsseite der Konversationen und die Anzeige der einzelnen Chats mit dieser Technologier verbunden. Deshalb konnte nicht ,wie ursprünglich geplant, lediglich die Chat-Seite durch Flutter ersetzt werden sondern auch die davorliegende Übersichtsseite. Von einer Änderung der Webimplementierung wurde abgesehen, da dies zu einer Performanceverschlechterung der Web-Version geführt hätte.


\subsection{Benutzte Plugins}
Es wurden die selben Plugins benutzt wie in der Flutter Implementierung. Jedoch wird ein zusätzliches WebView Plugin benötigt um die hybride Implementierung zu ermöglichen. Hierfür wird das von Flutter veröffentliche \verb|webview_flutter|\footnote{https://pub.dev/packages/webview\_flutter} Plugin genutzt. Die Wahl des richtigen Plugins war dabei eine recht komplizierte, da die unterschiedlichen Plugins nur einzelne Plattformen unterstützen, jedoch keine alle möglichen anbietet. Deswegen wurde beschlossen, das offizielle Plugin von Flutter zu nutzen und die unterstützten Plattformen auf Android und iOS beschränkt.



\subsection{Fazit}
Diese Implementierung war wie die hybride Implementierung sehr schnell, da Große Teile der Anwendung durch die Webseite bereits geliefert werden. Sie war jedoch dabei deutlich umfangreicher und durch das Ersetzen der Webnavigation durch eine Flutter-Navigation wirken selbst in der WebView angezeigte Inhalte wie nativ entwickelte Benutzeroberfläche. Dazu kommt, dass durch das gezielte Ersetzen von den Teilen der Anwendung, die in einer Applikationsimplementierung  besser dargestellt beziehungsweise eine bessere Funktionalität erhalten, die Nutzung der Anwendung vereinfacht wird. Die Teile der Anwendung, die jedoch von einer derartigen Änderung nicht profitieren, können weiterhin durch die Webapplikation genutzt und somit Entwicklungszeit gespart werden. Außerdem ermöglicht dieser Ansatz, dass ein Umbau von Webanwendung zu Applikation iterativ möglich ist und somit eine Version früher veröffentlicht werden kann.

Jedoch entstanden durch die Nutzung des gemischten Ansatzes einige Problemstellungen, die bei anderen Implementierungen nicht auftreten und für die es oft auch wenig Hilfestellungen in Foren oder Dokumentationen gibt. Daher ist dieser Ansatz mit einem erhöhten Aufwand verbunden, als wenn ein anderer Ansatz genutzt wird.