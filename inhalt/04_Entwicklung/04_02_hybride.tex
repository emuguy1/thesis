\section{Entwicklung Hybrider Android Applikation mit WebView}

Eine zweite Implementierung auf die im Folgenden eingegangen wird ist eine hybride Applikationen. 

\subsection{Grundlagen}
Der große Vorteil dieser Implementierung ist die Entwicklungsgeschwindigkeit, die hier erreicht werden kann, um eine Webseite in eine App zu bringen. Anstatt also die Anwendung komplett neu zu schreiben und somit getrennte Anwendungen zu schaffen, holt dieser Ansatz die bestehende Webseite in eine native Applikation. 

a\TODO{Wenn Level am Anfang eingearbeitet werden dann hier nochmal erwähnen}
Um eine grundlegende Implementierung zu erhalten, braucht man lediglich eine native Applikation, die eine WebView\footnote{https://developer.android.com/reference/android/webkit/WebView} enthält. Dabei kann in unter einer halben Stunde eine erste Version geschaffen werden,
Damit ist es jedoch noch nicht getan, denn damit die verschiedenen funktionalitäten der Webseite funktionieren müssen einige Konfigurationen getroffen werden.

Eine erste Konfiguration ist, JavaScript entweder zu erlauben oder zu unterdrücken. Wenn die in der App angezeigte WebAnwendung JavaScript in der funktionalität nutzt, muss diese funktion aktiviert werden. Es reduziert jedoch auch die Sicherheit, da fremde Webseiten oder Skripte über JavaScript Angriffe auf den Nutzer gefahren werden. Da allerdings die meisten Webseiten in irgendeiner Weise JavaScript nutzen, muss dies fast immer aktiviert werden. Um dennoch die Nutzer zu schützen, kann man deswegen bei externen Links reagieren und diese in einem externen Browser-Fenster des Smartphones öffnen. Hier gibt es etwa so genannte \verb|CustomTabsIntent|\footnote{https://developer.android.com/reference/androidx/browser/customtabs/CustomTabsIntent}. Dadurch erhält man ein Browsertab, dass noch auf die eigene Seite im Styling angepasst werden kann, aber als externer Inhalt erkennbar ist.

Um dies zu erreichen muss jedoch erst die aufgerufenen URLs abgefangen werden und dann entschieden werden, wie man mit der aufgerufenen URL umgeht. So ist eine einfache Konfiguration, dass man alle URLs die zur eigenen Webseite gehören zulässt, während man andere auf das \verb|CustomTabsIntent| umleitet. Um dies zu erreichen muss demr WebView eine eigener ChromeClient zugeordnet werden und die Funktion\verb|shouldOverrideUrlLoading| überschrieben werden\footnote{https://developer.android.com/reference/android/webkit/WebViewClient\#shouldOverrideUrlLoading(android.webkit.WebView,\%20android.webkit.WebResourceRequest)}.Hier sollte man jedoch auf eine möglichst effektive Implementierung achten, da jeder einzelne URL Aufruf wiederum diese Funktion aufruft.

Eine letzte Konfiguration, um die meisten Webseiten zum sicheren laufen zu bringen ist es, den \verb|UserAgent| Text zu setzen. Der UserAgent ist eine Text Flagge, die in einem HTTP-Packet zu finden ist. Sie definiert dabei Informationen zu dem benutzten Client oder der genutzten Hardware. Außerdem wird sie auch genutzt, um eventuell verdächtige Anfragen abzufangen, in dem der UserAgent Text analysiert wird\cite{UserAgentString}. Wenn man nun etwa einen Google Log-In auf der Webseite nutzt, würde Google die Anfrage nicht akzeptieren, da der \verb|UserAgent| standardmäßig nicht gesetzt ist. Deswegen muss dieser gesetzt werden.

Nach diesen Konfigurationen hat man nun eine vollkommen funktionierende Appllikation, die dabei sehr schnell erstellt werden kann. Theoretisch könnte man an diesem Punkt die Applikation so veröffentlichen. Jedoch ist es an diesem Punkt dem Nutzer noch sehr sichtbar, dass es sich bei dem Inhalt um eine Webseite handelt. Dafür kann man die erstellte Layout-Datei um einige native Elemente erweitern. Dadurch erreicht man Level 2 der hybriden Apps.
\TODO{Level 2 entfernen wenn nicht in klassifizierung erläutert}

Wie bereits in der Klassieifzierung der Ansätze erklärt, könnte man nun noch weiter gehen und Funktionalität hinzufügen, jedoch würde dafür eine umfangreichere Programmierung und die richtige Technologie der Webseite nötig. Da dies hier nicht gegeben ist, wird diese Implementierung auf diesem Stand gelassen. 

\subsection{Fazit(muss wsl. wo anders hin) zu hybrid}
Der größte Vorteil dieses Ansatzes ist eine wahnsinnig schnelle Entwicklungszeit. Wie zu sehen ist, kann innerhalb eines Tages eine erste veröffentlichbare Version für eine Plattform erstellt werden. Dies muss zwar auf allen Plattformen durchgeführt werden, so dass die Entwicklungszeit auf einem derartigen Level bei etwa einer Woche liegen dürfte. Ein weiterer Vorteil ist, dass Änderungen am Inhalt der angezeigten Anwendung nicht erst auf den Geräten der Nutzer installiert werden müssen, sondern Änderungen nach einem Neuladen der Webseite bei allen Nutzern sofort verfügbar ist. Dazu kommt, dass an der Applikation nur sehr selten Änderungen durchgeführt werden müssen, da hier in den meisten Fällen nicht viel Logik verbaut ist. Wenn man außerdem auf eine höhere Stufe wie etwa Level 3 oder 4 weiterentwickeln will, dann kann dies sehr gut in einem iterativen Ablauf passieren, da die Webseite als Übergangslösung genutzt werden kann, bis der native Code Teil dazu auf den Plattformen verfügbar ist.

Ein erster Nachteil ist, dass diese Apps nur nutzbar sind, wenn eine aktive Internetverbindung besteht, da Teile der App aus der Webseite bestehen. Dazu kommt, dass mit den höheren Levels dieses Ansatzes, der Programmier- und Wartungsaufwand wieder steigt. Dies wird auch dadurch verschärft, dass bei diesem Ansatz wieder eine Lösung für jede Plattform einzeln geschaffen werden muss. Eines der größten Problem für diese Klasse stellen jedoch die Review Guidelines des Apple AppStores dar\footnote{https://developer.apple.com/app-store/review/guidelines/\#minimum-functionality}. Diese legen fest, dass die App nicht einfach nur ein Container für eine Webseite sein darf, sondern zu großen Teilen aus für den Nutzer nützlichen Funktionalitäten bestehen muss. Dadurch ist die Gefahr hoch, dass die App von Apple nicht veröffentlicht wird, wenn man nicht viel zusätzliche Funktionalität hinzufügt. 