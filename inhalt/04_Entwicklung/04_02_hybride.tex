\section{Entwicklung einer hybriden Android Applikation mittels eines WebView-Containers}
Der zweite realisierte Ansatz ist eine hybride Applikation, die mit Kotlin implementiert wurde. 
Da einerseits die Implementierung der Web-Komponente durch viele verschiedene Ansätze umgesetzt werden kann und andererseits in diesem Fall bereits eine Webseite existiert, wird folglich nur auf die Implementierung der Schnittstelle eingegangen. 
Um ein besseres Verständnis über die Funktionalität des hybriden Ansatzes zu erhalten, wird auf die Nutzung eines Frameworks verzichtet und die Schnittstelle zwischen der eingebundenen Webseite und der Plattform nativ entwickelt.
Dabei wird die grundlegende Funktionalität ermöglicht. Eine umfänglichere Nutzung von Plattformfunktionalität wird in einem Exkurs vorgestellt.

\subsection{Grundlagen}
Um eine Minimalversion zu erhalten, wird eine native Applikation benötigt, die eine WebView-Komponente\footnote{https://developer.android.com/reference/android/webkit/WebView} enthält. Um die Funktionalität der Webseite zu ermöglichen, müssen unter Anderem die folgenden Aspekte beachtet werden.

So benutzen rund 98\% aller Webseiten JavaScript in ihrem Code, um zum Beispiel ein Menü ein oder auszublenden, ohne die Seite neu laden zu müssen \footnote{https://w3techs.com/technologies/details/cp-javascript}. 
Dazu muss jedoch JavaScript in der WebView aktiviert werden. 
Jedoch kann die Aktivierung von JavaScript ein Sicherheitsrisiko darstellen. So können etwa fremde Webseiten ebenfalls versuchen, auf das Gerät zuzugreifen \cite{webview_javascript_security}. 
Daher sollte die Implementierung externe Links erkennen und diese in einem externen Browser-Fenster öffnen.
Die Links können dabei entweder in dem normalen Browser des Gerätes geöffnet werden oder in einem CustomTabsIntent\footnote{https://developer.android.com/reference/androidx/browser/customtabs/CustomTabsIntent}.
Dadurch entsteht ein Browsertab in der eigenen Applikation, dass etwa in der Akzentfarbe der Applikation angepasst werden kann um eine Zugehörigkeit erkennbar zu machen, jedoch dennoch einen externen Browser zu erhalten. Es ist jedoch durch die angezeigte Funktionsleiste mit angezeigter URL am oberen Bildschirmrand dennoch als externer Inhalt erkennbar.

Um dies zu ermöglichen muss jedoch die aufgerufene URL abgefangen werden und entschieden werden, wie mit der aufgerufenen URL verfahren werden soll. So ist eine einfache Grundkonfiguration, dass alle URLs die zur angezeigten Webapplikation gehören zugelassen werden, während externe Links weitergeleitet werden.

Eine letzte Konfiguration, die benötigt wird um etwa das Login mit Google zu ermöglichen ist das Setzen eines UserAgentStrings. Er ist eine Text Flagge, die in einem HTTP-Paket zu finden ist. Sie beinhaltet Informationen zu dem benutzten Client oder der genutzten Hardware. Außerdem wird sie auch genutzt, um verdächtige Pakete heraus zu filtern\cite{UserAgentString}. So filtert Google LogIn-Anfragen herraus, bei denen der UserAgent nicht gesetzt ist. Dieser kann durch das Setzen der Variable auf dem Webcontainer definiert werden.

Mit diesen Konfigurationen ist eine grundsätzliche Funktionalität einer Webapplikation sichergestellt. So kann an diesem Punkt theoretisch eine erste Version veröffentlicht werden. Jedoch ist an diesem Punkt dem Nutzer immer noch sichtbar, dass es sich bei dem Inhalt um eine Webseite handelt. Um dies zu verhindern können über die Layoutdatei native Elemente über oder um das WebView anlegen. So kann etwa ein Home Button dem Layout hinzugefügt werden, um der Anzeige native Elemente hinzuzufügen.

Neben der Konfiguration des Aussehens kann die WebApplikation noch in der benutzung von Gerätefunktionalität angepasst werden. Auf eine derartige mögliche Erweiterung soll deswegen im Folgenden Exkurs etwas eingegangen werden.

\subsection{Exkurs: Nutzung von Plattformfunktionalität}
Wie in Kapitel \ref{cha:3_hybrid} erwähnt, haben hybride Applikationen die Möglichkeit auf Plattformfunktionalität zuzugreifen. Dies ist der Teil, den Frameworks typischer Weise bereits umgesetzt haben und um die ein Entwickler sich normalerweise keine Gedanken machen muss. Jedoch wird in dieser Arbeit kein Framework genutzt, um einen Möglichen Ansatz zu zeigen, dies in die eigene Applikation zu integrieren. So kann ein von der App initialisiertes und der WebView hinzugefügtes WebAppInterface\footnote{https://developer.android.com/guide/webapps/webview\#BindingJavaScript} direkt aus dem JavaScript der Webseite aufgerufen werden \cite{webview_javascript_security}. Dafür werden Objekte und ihre öffentlichen Methoden dem Webcontainer unter einem definierten Namen zur Verfügung gestellt. Es können dabei sowohl Daten gesendet als auch empfangen werden.

Auch kann aus der Applikation JavaScript Code aufgerufen beziehungsweise ausgeführt werden. Dafür wird mit der loadUrl Methode, die in der WebView normalerweise einen Link aufruft, JavaScript-Code mit dem Präfix \verb|"javascript:"| der WebAnwendung hinzugefügt \cite{webview_javascript_security}. Dies kann sowohl selbst geschriebener Code als auch ein Aufruf bereits definierter Methoden sein. Dies zeigt jedoch, dass auch innerhalb der Webanwendung ein besonderes Augenmerk auf die Sicherheit gesetzt werden muss, da unter Umständen neben der Applikation, auch die Webseite angreifbar ist. So könnten bösartige Applikationen versuchen, über die JavaScript Schnittstelle eigenes JavaScript auszuführen, um so etwa den aufgerufenen Webserver zu attackieren. Dies ist möglich, da JavaScript-Code, der über loadUrl hinzugefügt wurde, im aktuell angezeigten Kontext gleichwertig wie von von der Webanwendung stammendes JavaScript ausgeführt wird \cite{webview_javascript_security},

\subsection{Fazit hybride Implementierung}
Ein Vorteil dieser Implementierung ist die Entwicklungsgeschwindigkeit, die erreicht werden kann, wenn bereits eine Webanwendung existiert. Anstatt die Anwendung komplett neu zu schreiben und somit multiple Implementierungen der Anwendungslogik zu erstellen, kann mit diesem Ansatz die Webanwendung in eine native Applikation eingebettet werden.
Ein weiterer Vorteil ist, dass durch die Nutzung der extern gehosteten Webanwendungen, Änderungen am Inhalt der angezeigten Anwendung nicht erst auf den Geräten der Nutzer installiert werden müssen, sondern direkt nach einem Neuladen der Webseite bei allen Nutzern verfügbar ist. 
Dazu kommt, dass an der eigentlichen Applikation nur sehr selten Änderungen durchgeführt werden müssen, da hier in den meisten Fällen nicht viel Logik verbaut ist.

Ein Nachteil ist, dass in diesem Fall die App nur nutzbar ist, wenn eine aktive Internetverbindung besteht, da der Großteil der angezeigten App, aus der Webseite bestehen. Dazu kommt, dass der Programmier- und Wartungsaufwand steigt, wenn eine umfangreiche Nutzung von Gerätefunktionalität geplant ist. Des Weiteren wird bei dieser Implementierungsart wieder eine eigene Implementierung des nativen Containers für jede Plattform benötigt., dies kann jedoch durch die Nutzung eines Frameworks verhindert werden. Ein Problem für diese Art der Entwicklung sind jedoch die Review Guidelines des Apple AppStores\footnote{https://developer.apple.com/app-store/review/guidelines/\#minimum-functionality}. Diese legen fest, dass die App nicht einfach nur ein Container für eine Webseite sein darf, sondern zu großen Teilen aus für den Nutzer nützlichen Funktionalitäten bestehen muss. Dadurch ist es wahrscheinlich, dass eine Implementierung im Umfang der hier dargestellten Applikation von Apple nicht veröffentlicht werden würde, wenn nicht noch zusätzliche Funktionalität hinzufügt wird.

Einige der Vor und Nachteile sind jedoch stark von der hier vorgestellten Implementierung abhängig. So wird etwa durch die Nutzung einer lokal gespeicherten Implementierung eine offline Funktionalität erreicht, jedoch müssen dadurch Änderungen über den normalen Updateprozess der einzelnen Plattformen verteilt werden.
Auch kann die gesamte Implementierung durch die Nutzung von Frameworks erledigt werden, jedoch muss die Webseite dann an dieses Framework angepasst werden und die nutzbare Funktionalität durch die implementierten Lösungen eingeschränkt sein. 
