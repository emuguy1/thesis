\section{Die verschiedenen Appentwicklungs Framework Klassen}
Für die Programmierung von Multi-Plattform-Applikationen gibt es verschiedene Klassen, in die die Entwicklungsmethoden eingeordnet werden können. Dabei unterscheiden verschiedene Autoren unterschiedliche Klassen. In dieser Arbeit wird daher der von Delia et al \cite{IEEE_development_classes} definierten Einteilung gefolgt, da ihre Definition ein vernünftiger Pfad zwischen zu detailliert und zu generell ist. Im Folgenden sollen diese vorgestellt und auf einige Aspekte der einzelnen Klassen eingegangen werden.

\subsection{Native Applikationen}
Native Applikationen werden entwickelt, um auf einer bestimmten Plattform installiert zu werden. Der Quellcode wird dafür zu ausführbaren Code übersetzt, der spezifisch für die gewählte Plattform ist \cite{IEEE_development_classes}.
Die Programmierung wird in der für die Plattform typischen Programmiersprache geschrieben und ist dadurch nur für eine Plattform nutzbar. Es gibt folglich für jede Plattform einen eigenen Quellcode. Um etwa eine native Android App zu entwickeln, wird diese in Kotlin programmiert und im Anschluss in Kotlin-Bytecode übersetzt. Dieser Bytecode ist daher nur auf Android Geräten ausführbar.

Der Vorteil der nativen Entwicklung ist, dass man die Funktionen der verschiedenen Plattform optimal nutzen kann. So ist etwa eine Nutzung der Kamera, GPS, Beschleunigungssensoren, Kalender und vielem mehr sehr einfach. Es gibt eindeutig definierte Schnittstellen und diese müssen nur aufgerufen werden. Dabei ist die Ausführung nicht nur schnell, sondern kann auch einfach im Hintergrund ausgeführt werden \cite{IEEE_development_classes}. Dazu kommt, dass das Aussehen und die Benutzerschnittstellen ähnlich zu dem Gesamtsystem sind. So entsteht für den Nutzer ein geschlossenes System, das leichter zu bedienen ist, da es keine Unterschiede in Struktur, Design, Aufbau oder auch Benutzung gibt \cite{IEEE_Khackouch_Al}.

Einer der größten Nachteile der nativen Entwicklung jedoch ist der Aufwand und die damit verbundenen Kosten, um für die verschiedenen Plattformen eine Applikation anbieten zu können. Denn die Applikation muss für jede Plattform komplett neu gebaut werden. So können die Kosten für eine Plattform mit der Anzahl der abzudeckenden Plattformen multipliziert werden, um die Gesamtkosten zu erhalten \cite{IEEE_Khackouch_Al}. Doch nicht nur die Programmierung ist ein Kostenfaktor. So nennen Delia et al das Testen, Warten und Verteilen neuer Version als Faktoren, die auf jeder einzelnen unterstützten Plattform auftreten \cite{IEEE_development_classes}. Dazu kommt, dass man für jede Plattform auch Entwickler benötigt, da sich die wenigsten Entwickler auf allen Plattformen auskennen und Anwendungen für die verschiedenen Plattformen oft auch gleichzeitig entwickelt werden sollen. Um große Kosten zu verhindern, werden deswegen häufig nur  eine oder zwei Plattformen ausgewählt, wodurch die Reichweite der Anwendung sinkt.

\subsection{Web-Applikationen}
Web-Applikationen sind Applikationen, die im Netz verfügbar sind. Sie sind darauf ausgelegt, als Webseiten auf einem Server zu laufen und dann über den Browser der Geräte aufgerufen zu werden. Dieser Ansatz ist simpel, da eine Webseite sofort für jeden Nutzer verfügbar ist, sobald sie auf dem Server gestartet wurde. Sie muss auch nur einmal entwickelt werden, da sie auf allen Geräten mit einem Browser und einer Internetverbindung aufgerufen werden kann. So kann man alle Plattformen mit nur einer Entwicklung abdecken \cite{IEEE_development_classes}.

Wie gerade erwähnt, wird ein Code für alle Plattformen geschrieben. Dies ist natürlich ein großer Pluspunkt, falls die Entwicklungskosten stark eingeschränkt sind. Außerdem stehen dem Nutzer Updates direkt nach einem Neustart des Servers zur Verfügung, da es nicht erst an die Geräte verteilt und dann installiert werden muss \cite{IEEE_Khackouch_Al}.

Jedoch hat man hier große Einschränkungen in der Funktionalität, da lediglich die Funktionen des Browser zur Verfügung stehen. So können derartige Anwendungen die nativen Schnittstellen nicht benutzen und sind in ihrer Funktionalität stark beschränkt \cite{Phyo}. Dazu kommt, dass falls keine Internetverbindung vorhanden ist, die Anwendung gar nicht genutzt werden kann und bei einer langsamen Internetverbindung die Performance signifikant sinkt \cite{IEEE_Khackouch_Al}. Außerdem müssen Webanwendungen auch angepasst werden, um gut auf einem mobilen Endgerät genutzt werden zu können. So sind Smartphones etwa höher als sie breit sind, während Computerbildschirme breiter sind als sie hoch sind. Dementsprechend muss etwa eine Menüleiste darauf reagieren können und je nach Seitenverhältnis beziehungsweise Auflösung ein anderes Design anbieten. Dadurch muss Zeit investiert werden, um Webseiten zu entwickeln, die auf allen Geräten gut nutzbar sind.

Web-Applikationen sind zwar gerade in den letzten Jahren durch die Verfügbarkeit von schnellen Internetverbindungen in fast allen Gebieten der Welt, immer einfacher nutzbar geworden.
Im Schnitt stieg die mobile Bandbreite zwischen 2017 und 2021 um 59,5\% beziehungsweise von knapp 20 \ac{Mbps} auf 55\ac{Mbps} \footnote{https://www.ookla.com/articles/global-index-2019-internet-report}.
Jedoch ergab eine Studie von Yoram Wurmser \cite{report_webusage}, dass während der Smartphonebenutzung etwa 89\% der Zeit in Applikationen und gerade einmal 11\% in einem Browser verbracht wird.
Da also ein deutlich höherer Fokus auf tatsächlich auf dem Gerät installierbaren Anwendungen liegt, wird diese Klasse in der Arbeit nicht genauer betrachtet.

\subsection{Hybride Applikationen}
Eine Klasse die viel mit der vorherigen Klasse zu tun hat und in dieser Arbeit genauer betrachtet werden soll, sind die hybriden Apps. Sie nutzen Web-Technologien, also HTML, Javascript und CSS, werden jedoch nicht im Browser des Geräts aufgerufen, sondern in einem nativen Container ausgeführt \cite{IEEE_development_classes}. die zu einem Teil aus nativem Code bestehen und zu einem anderen Teil aus einem Web-Container in dem Inhalte entweder direkt aus dem Netz angezeigt werden, oder lokal gespeicherte Seiten gezeigt werden. Sie benutzen also Web-Technologien, benutzen dabei aber nicht den Browser, sondern einen eigenen Web-Container. Unter Umständen kann dieser mit Hilfe von bestimmten API-Schnittstellen auf gerätespezifische Funktionen zugreifen \cite{IEEE_development_classes}.
\TODO{Vielleicht noch ein Bild zur Architektur einbauen siehe: https://fh-bielefeld-mif-sw-engineerin.gitbooks.io/klausurthemen/content/fullstack-development/Hybride\_AppEntwicklung/WebApps\_NativeApps\_HybrideApps.html}

 

Grundsätzlich hat diese Klasse die gleichen Vor- und Nachteile wie die vorherige, da sie zu einem großen Teil aus einer Web-Applikation bestehen, die in einer nativen App angezeigt werden. Es gelten hier jedoch einige Ausnahmen, auf die auch noch einmal genauer in dem Kapitel mit der Implementierung zu dieser Klasse eingegangen wird. Denn je nach Art von hybrider App werden einzelne Probleme durch spezielle Implementierungen gelöst.Was jedoch immer ist, ist dass in den meisten Benutzeroberflächen weiterhin keine nativen Komponenten genutzt werden können und durch das Laden von Container und Website die Performance sinkt \cite{IEEE_development_classes}. Des weiteren kann die Anwendung auch weiterhin nicht im vollen Umfang genutzt werden, wenn keine Internetverbindung hat. Man hat allerdings auch eine extrem schnellere Entwicklungszeit bei bestehender Web-Anwendung, abhängig vom Umfang der nativen Integration.

\subsubsection{Cross-Plattform Applikationen}

Die letzte Klasse sind Multi-Plattform Applikationen. Sie zeichnen sich dadurch aus, dass jeweils nur ein Code geschrieben wird und am Ende eine Applikation für mehrere Plattformen entsteht.\TODO{Das hier entfernen} 

Sie haben den großen Vorteil, dass sie in der Entwicklung deutlich billiger sind als wenn man eine Anwendung für jede Plattform eine eigene Schreiben würde. Auch die Entwicklungszeit wird dadurch oft deutlich verkürzt. Durch die Devise, dass nur ein Code geschrieben wird, treten hier auch seltener Ungereimtheiten bei der Definition und Benutzung der Schnittstellen zu etwa einem Server. Auch Logikfehler treten wenn dann bei allen Anwendungen auf und nicht nur bei bestimmten. Dies klingt zwar im ersten Moment erstmal negativ, ist aber insofern gut, da Fehler dadurch leichter reproduzierbar sind und auch bereits beim testen sofort auffallen sollten, da man lediglich einen Code testen muss.

Nachteile die für diese Entwicklungsform sind oft Frameworkspezifisch. So ist etwa ein Problem, dass manchmal nicht alle Plattformfunktionen ohne Einschränkungen genutzt werden können. Des weiteren ist bei manchen ein Kritikpunkt, dass die UI nicht Geräte-typisch aussieht. Diese Probleme sind jedoch auch Abhängig von der Art, wie die Anwendung übersetzt wurde. Im folgenden soll deswegen in zwei Gruppen unterschieden werden.

\subsection{Interpretierte Cross-Plattform Anwendungen}
Bei Interpretieren Cross-Plattform Anwendungen schreibt der Entwickler einen Code, der wird dann mithilfe von nativen Code während der Laufzeit in ausführbaren Code übersetzt. Das bedeutet, dass die auf dem Gerät installierte Anwendung einen nativen Teil, oftmals Frameworkcode zum Übersetzen, und einem Cross-Plattform Teil, der Anwendungslogik, besteht \cite{IEEE_development_classes}.

Wie man bereits vermuten kann ist ein Problem dieser Klasse, dass bei der Ausführung eine Zwischenschicht vorhanden ist, die für zusätzliche Latenz der Ausführung führt.

\subsection{Compilierte Cross-Plattform Anwendungen}
Das Problem der zusätzlichen Latenz kann durch diese Klasse verhindert werden, weswegen auch nur diese in der Arbeit untersucht wurde. Denn bei kompilierten Cross-Plattform Anwendungen wird zwar während der Entwicklung nur ein Quellcode geschrieben, jedoch wird nach der Entwicklung eine Anwendung für jede Plattform gebaut, die nur aus nativen Teilen besteht \cite{IEEE_development_classes}.
